subdesign contadorfm
(
	clock1s			: input; %clock de entrada do contador%
	%s3, s4 		: input; %seletor de controle( decrescente/crescente)%
	sw1, sw2, sel	: INPUT; %switches amfm, modo gravação e seletor de a/d%
	clock_Placa 	: input; %clock da placa%
	1d[3..0], 2d[3..0], 3d[3..0], 4d[3..0] 	: output; %valor de Saida%
)

VARIABLE
	ff[10..0] 			: DFF; %flip flops tipo D%
	d[10..0] 			: NODE; %entradas Ds dos Flip Flops%
	q[10..0] 			: NODE; %saidas Qs dos Flip Flops%
	saida_aux[10..0]	: NODE; %vetor auxiliar usado para realimentar a saida quando necessario%
	fft					: TFF;
	
BEGIN
	%if 1dfm[] == GND then
		1dfm[] = B"0110"%	
	ff[].clk = clock; %clock de entrada como clock dos flip flops%
	ff[].d = d[]; %entradas dos flip flops%
	q[] = ff[].q; %saidas dos flip flops%
	saida[] = saida_aux[]; %saida do sistema%
	fft.clk = s3;
	fft.t = VCC;
	if (sw2 == GND & sw1 == GND) then 	%só acontece caso fora do modo gravação e sw1 em fm%
		if sel == VCC then				%acresimo%

	end if;





		
		CASE  IS
			WHEN ( MOD 2) =>
				%CASE que seleciona o tipo de operacao a ser feita de acordo com o controle%
			
				END CASE;
				
				%IF que garante a saida modulo 60 e alimenta a entrada do detector de borda somente quando a contagem vai de 59->0%
				IF q[] == 10 THEN %caso de contagem crescente de 9 -> 0%
					saida_aux[] = 0;
				ELSIF q[] == 15 THEN %caso de contagem decrescente de 0->9%
					saida_aux[] = 9;
				ELSE %caso padrao%
					saida_aux[] = q[];
				END IF;			
			
END;